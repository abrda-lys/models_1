<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Babylon.js - Измерение расстояния с Ctrl и шариками</title>
  <style>
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    #distanceDisplay {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 18px;
      background: rgba(0,0,0,0.5);
      padding: 8px;
      border-radius: 8px;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="distanceDisplay">Расстояние: 0 м</div>

  <script>
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);
    let scene, camera;

    let ctrlDown = false; // Флаг для проверки зажатия Ctrl

    window.addEventListener('DOMContentLoaded', () => {
      scene = createScene();
      engine.runRenderLoop(() => scene.render());
    });

    window.addEventListener('resize', () => engine.resize());

    // Отслеживание нажатия Ctrl
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Control') {
        ctrlDown = true;
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'Control') {
        ctrlDown = false;
      }
    });

    function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.1, 1);

      camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.5, 5, BABYLON.Vector3.Zero(), scene);
      camera.attachControl(canvas, true);

      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

      // Загрузка модели
      BABYLON.SceneLoader.Append("https://models.babylonjs.com/", "boombox.glb", scene, function (scene) {
        console.log("Модель загружена!");
      });

      // Измерение расстояния
      let points = [];
      let markers = [];
      let line = null;
      const distanceDisplay = document.getElementById('distanceDisplay');

      scene.onPointerObservable.add((pointerInfo) => {
        if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERPICK) {
          const pickResult = pointerInfo.pickInfo;
          if (pickResult.hit && ctrlDown) {
            const pickedPoint = pickResult.pickedPoint.clone();
            points.push(pickedPoint);

            // Создаём маленький шарик в точке выбора
            const sphere = BABYLON.MeshBuilder.CreateSphere("marker", { diameter: 0.05 }, scene);
            sphere.position = pickedPoint;
            sphere.material = new BABYLON.StandardMaterial("markerMat", scene);
            sphere.material.diffuseColor = new BABYLON.Color3(1, 0, 0); // Красный цвет
            markers.push(sphere);

            if (points.length === 2) {
              const distance = BABYLON.Vector3.Distance(points[0], points[1]);
              distanceDisplay.innerText = `Расстояние: ${distance.toFixed(2)} м`;

              if (line) {
                line.dispose();
              }
              line = BABYLON.MeshBuilder.CreateLines("line", { points: [points[0], points[1]] }, scene);
              line.color = new BABYLON.Color3(0, 1, 0); // Зелёная линия

              // Очищаем точки для следующего измерения
              points = [];
              // Удаляем старые маркеры через секунду
              setTimeout(() => {
                markers.forEach(marker => marker.dispose());
                markers = [];
              }, 1000);
            }
          }
        }
      });

      return scene;
    }
  </script>
</body>
</html>
