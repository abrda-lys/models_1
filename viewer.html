<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Babylon.js - Измерение расстояния с Ctrl и шариками</title>
  <style>
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; background: #000; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    #distanceDisplay {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 18px;
      background: rgba(0,0,0,0.5);
      padding: 8px;
      border-radius: 8px;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="distanceDisplay">Расстояние: 0 м</div>

  <script>
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);
    let scene, camera;

    let ctrlDown = false;

    window.addEventListener('DOMContentLoaded', () => {
      scene = createScene();
      engine.runRenderLoop(() => scene.render());
    });

    window.addEventListener('resize', () => engine.resize());

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Control') ctrlDown = true;
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'Control') ctrlDown = false;
    });

    function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.05, 1);

      camera = new BABYLON.ArcRotateCamera("camera", Math.PI/2, Math.PI/3, 5, BABYLON.Vector3.Zero(), scene);
      camera.attachControl(canvas, true);

      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

      // Загружаем модель (например, бесплатная "авоська" с babylonjs-сервера)
      BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/", "BoomBox.glb", scene, function (meshes) {
        console.log("Модель загружена:", meshes);

        meshes.forEach(mesh => {
          mesh.scaling.scaleInPlace(20);
        });
      });

      // Логика измерения
      let points = [];
      let markers = [];
      let line = null;
      const distanceDisplay = document.getElementById('distanceDisplay');

      scene.onPointerObservable.add((pointerInfo) => {
        if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERPICK) {
          const pickResult = pointerInfo.pickInfo;
          if (pickResult.hit && ctrlDown) {
            const pickedPoint = pickResult.pickedPoint.clone();
            points.push(pickedPoint);

            const sphere = BABYLON.MeshBuilder.CreateSphere("marker", { diameter: 0.05 }, scene);
            sphere.position = pickedPoint;
            sphere.material = new BABYLON.StandardMaterial("markerMat", scene);
            sphere.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
            markers.push(sphere);

            if (points.length === 2) {
              const distance = BABYLON.Vector3.Distance(points[0], points[1]);
              distanceDisplay.innerText = `Расстояние: ${distance.toFixed(2)} м`;

              if (line) {
                line.dispose();
              }
              line = BABYLON.MeshBuilder.CreateLines("line", { points: [points[0], points[1]] }, scene);
              line.color = new BABYLON.Color3(0, 1, 0);

              points = [];
              setTimeout(() => {
                markers.forEach(marker => marker.dispose());
                markers = [];
              }, 1000);
            }
          }
        }
      });

      return scene;
    }
  </script>
</body>
</html>
