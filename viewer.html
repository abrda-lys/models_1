<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Просмотр модели</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #222;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .distance-label {
      position: absolute;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 4px 8px;
      border-radius: 4px;
      pointer-events: none;
      font-family: sans-serif;
      font-size: 14px;
    }
  </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="distanceLabel" class="distance-label" style="display: none;"></div>

<script>
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true);
  let scene, pickedPoints = [], line, distanceLabel = document.getElementById('distanceLabel');

  async function createScene() {
    scene = new BABYLON.Scene(engine);
    scene.createDefaultCameraOrLight(true, true, true);
    scene.createDefaultEnvironment();

    // Загружаем список моделей
    const response = await fetch('https://storage.yandexcloud.net/mymodels/models.txt');
    const text = await response.text();
    const lines = text.split('\n').map(line => line.trim()).filter(line => line);
    if (lines.length === 0) {
      alert("Нет моделей в списке!");
      return;
    }

    const firstModelUrl = lines[0].split(',')[1].trim(); // Берём ссылку на первую модель
    console.log("Загружаем модель:", firstModelUrl);

    await BABYLON.SceneLoader.AppendAsync("", firstModelUrl, scene);

    // Добавляем обработчик кликов для измерений
    scene.onPointerObservable.add((pointerInfo) => {
      if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERPICK 
          && pointerInfo.event.button === 0 
          && pointerInfo.event.ctrlKey) {

        const pickResult = pointerInfo.pickInfo;
        if (pickResult.hit) {
          const pickedPoint = pickResult.pickedPoint.clone();
          addMarker(pickedPoint);
          pickedPoints.push(pickedPoint);

          if (pickedPoints.length === 2) {
            drawMeasurement();
          }
        }
      }
    });

    return scene;
  }

  function addMarker(position) {
    const sphere = BABYLON.MeshBuilder.CreateSphere("marker", { diameter: 0.05 }, scene);
    sphere.position = position;
    const material = new BABYLON.StandardMaterial("markerMat", scene);
    material.diffuseColor = new BABYLON.Color3(1, 0, 0); // Красный
    sphere.material = material;
  }

  function drawMeasurement() {
    if (line) {
      line.dispose();
    }

    const points = [pickedPoints[0], pickedPoints[1]];
    line = BABYLON.MeshBuilder.CreateLines("line", { points: points }, scene);
    line.color = new BABYLON.Color3(1, 1, 0); // Жёлтая линия

    const distance = BABYLON.Vector3.Distance(points[0], points[1]);
    showDistanceLabel(distance, points);
    
    pickedPoints = []; // Сбросить точки после измерения
  }

  function showDistanceLabel(distance, points) {
    const midpoint = BABYLON.Vector3.Center(points[0], points[1]);
    const projected = BABYLON.Vector3.Project(
      midpoint,
      BABYLON.Matrix.Identity(),
      scene.getTransformMatrix(),
      scene.activeCamera.viewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight())
    );

    distanceLabel.style.left = (projected.x - 30) + "px";
    distanceLabel.style.top = (projected.y - 20) + "px";
    distanceLabel.innerText = distance.toFixed(2) + " м";
    distanceLabel.style.display = "block";
  }

  createScene().then(() => {
    engine.runRenderLoop(() => {
      scene.render();
    });
  });

  window.addEventListener("resize", function () {
    engine.resize();
  });
</script>
</body>
</html>
